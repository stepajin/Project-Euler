// Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
// Triangle         P3,n=n(n+1)/2       1, 3, 6, 10, 15, ...
// Square           P4,n=n^2            1, 4, 9, 16, 25, ...
// Pentagonal       P5,n=n(3n−1)/2      1, 5, 12, 22, 35, ...
// Hexagonal        P6,n=n(2n−1)        1, 6, 15, 28, 45, ...
// Heptagonal       P7,n=n(5n−3)/2      1, 7, 18, 34, 55, ...
// Octagonal        P8,n=n(3n−2)        1, 8, 21, 40, 65, ...

// The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

// The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
// Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
// This is the only set of 4-digit numbers with this property.

// Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

struct PolySequence: Sequence, IteratorProtocol {
    private let f: (Int) -> Int
    private let max: Int
    private var n = 1
    
    init(_ f: @escaping (Int) -> Int, max: Int) {
        self.f = f
        self.max = max
    }
    
    mutating func next() -> Int? {
        let value = f(n)
        guard value <= max else { return nil }
        n += 1
        return value
    }
}

extension Sequence {
    func firstValue<T>(_ transform: (Element) -> T?) -> T? {
        for element in self {
            if let value = transform(element) { return value }
        }
        return nil
    }
}

extension Array {
    subscript(n idx: Int) -> Element {
        get { self[idx-1000] }
        set { self[idx-1000] = newValue }
    }
}

func permutations(_ numbers: [Int]) -> [[Int]] {
    guard numbers.count > 1 else { return [numbers] }
    return numbers.indices.flatMap { idx -> [[Int]] in
        var _numbers = numbers
        let n = _numbers.remove(at: idx)
        return permutations(_numbers).map { [n] + $0 }
    }
}

func boolmap(_ f: @escaping (Int) -> Int) -> [Bool] {
    var flags = [Bool](repeating: false, count: 9000)
    PolySequence(f, max: 9999).lazy.filter { $0 >= 1000 }.forEach { flags[n: $0] = true }
    return flags
}

let boolmaps: [[Bool]] = [
    { n in n*(n+1)/2 },
    { n in n*n },
    { n in n*(3*n-1)/2 },
    { n in n*(2*n-1) },
    { n in n*(5*n-3)/2 },
    { n in n*(3*n-2) }
].map(boolmap(_:))

let prefixes = (1000...9999).map { String($0).prefix(2) }
let suffixes = (1000...9999).map { String($0).suffix(2) }

func numbersPrefixed(_ prefix: Substring) -> [Int] {
    struct Strings {
        static let strings = (10...99).map(String.init)
    }
    guard prefix.first != "0" else { return [] }
    return Strings.strings.map { prefix + $0 }.compactMap(Int.init)
}

func search(_ n: Int, _ path: [Int], _ boolmapOrder: [Int], depth: Int) -> [Int]? {
    guard boolmaps[boolmapOrder[depth]][n: n] else { return nil }
    let newPath = path + [n]
    if depth == 0 {
        return suffixes[n: n] == prefixes[n: path[0]] ? newPath : nil
    }
    return numbersPrefixed(suffixes[n: n]).firstValue {
        search($0, newPath, boolmapOrder, depth: depth-1)
    }
}

let boolmapOrders = permutations(Array(1...5)).map { [0] + $0 }

let path = boolmapOrders.firstValue { order in
    (1010...9999).firstValue { search($0, [], order, depth: 5) }
}!
let result = path.reduce(0, +)
print(result)
